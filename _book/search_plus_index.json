{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction powered by Gitbook文档更新时间： 2021-03-22 15:56:11 "},"JVM内存.html":{"url":"JVM内存.html","title":"JVM","keywords":"","body":"内存管理? （虚拟机如何使用内存？） ​ 内存泄露、oom ​ gc 执行子系统? 程序编译与优化? 高效并发?（如何让java程序有更高的并发性？） JVM的工作原理? （结合实践） java程序是如何运行的? OSGI 模块化 Java内存 结构 JVM 内存结构是指：Java 虚拟机定义了若干种程序运行期间会使用的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁，另一些则与线程一一对应，随着线程的开始而创建，随着线程的结束而销毁 线程： ​ 线程共享 ​ 线程私有 异常： StackOverflowError：java虚拟机栈、本地方法栈 OutOfMemoryError：java虚拟机栈、本地方法栈、方法区、堆 JVM内存布局和相应控制 线程共享 Java堆(Heap) Java 堆是所有线程共享的一块内存区域，它在虚拟机启动时 就会被创建，并且单个 JVM 进程有且仅有一个 Java 堆。Java 堆是用来存放对象实例及数组，也就是说我们代码中通过 new 关键字 new 出来的对象都存放在这里 方法区（Method Area） 它存储了每个类的结构信息，例如运行时常量池、字段、方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。 常量池 String类的intern()方法 线程私有 跟线程同时创建，所以它跟线程有相同的生命周期 Java 虚拟机栈（JVM Stacks） 每一个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中的入栈到出栈的过程 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。 其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余的数据类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小 Java 虚拟栈中可能出现两种异常： StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度 OutOfMemoryError：虚拟机栈扩展时无法申请到足够的内存 本地方法栈（Native Method Stacks） 本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是 Java 虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。 程序计数器（Program Counter Register） 程序计数器也是线程私有的，它只需要一块较小的内存空间，每条线程都要有一个独立的程序计数器，你可以把它看作当前线程所执行的字节码的行号指示器 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 如果线程正在执行 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址 如果执行 native 方法，则计数器为空 程序计数器是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。 特殊（直接内存） 直接内存(Direct Memory)不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中的内存区域，但也可能导致OutOfMemoryError NIO：DirectByteBuffer直接操作，避免Java堆和Native堆来回赋值数据 对象访问 jvm层面引用(reference) （1）强引用（Strong Reference） （2）软引用（Soft Reference） （3）弱引用（Weak Reference） （4）、虚引用（Phantom Reference） 对象访问方式 主流的对象访问方式有两种： 使用句柄 Java堆划分一块内存作为句柄池，reference中存储就是对象的句柄地址； ​ 对象句柄包含两个地址： ​ （1）、在堆中分配的对象实例数据的地址； ​ （2）、这个对象类型数据地址； ​ 优点：对象移动时（垃圾回收时常见的动作），reference不需要修改，只改变句柄中实例数据指针； 使用直接指针 reference中存储就是在堆中分配的对象实例数据的地址； ​ 而对象实例数据中需要有这个对象类型数据的相关信息（前面文章讨论了HotSpot使用对象头来存储对象类型数据地址） 内存分配策略(垃圾收集) GC三件事： ​ 1、哪些内存需要回收？ ​ 2、什么时候回收？ ​ 3、如何回收？ 概述 什么是垃圾回收 垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。 怎么定义垃圾 既然我们要做垃圾回收，首先我们得搞清楚垃圾的定义是什么，哪些内存是需要回收的。 引用计数算法 引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加 1，如果删除对该对象的引用，那么它的引用计数就减 1，当该对象的引用计数为 0 时，那么该对象就会被回收。 String m = new String(\"jack\"); 先创建一个字符串，这时候\"jack\"有一个引用，就是 m。 然后将 m 设置为 null，这时候\"jack\"的引用次数就等于 0 了，在引用计数算法中，意味着这块内容就需要被回收了。 m = null; 问题：相互引用 public class ReferenceCountingGC { public Object instance; public ReferenceCountingGC(String name){} } public static void testGC(){ ReferenceCountingGC a = new ReferenceCountingGC(\"objA\"); ReferenceCountingGC b = new ReferenceCountingGC(\"objB\"); a.instance = b; b.instance = a; a = null; b = null; } 可达性分析算法 可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。 GC ROOT GC Root 的对象包括以下 4 种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 虚拟机栈（栈帧中的本地变量表）中引用的对象 此时的 s，即为 GC Root，当 s 置空时，localParameter 对象也断掉了与 GC Root 的引用链，将被回收。 public class StackLocalParameter { public StackLocalParameter(String name){} } public static void testGC(){ StackLocalParameter s = new StackLocalParameter(\"localParameter\"); s = null; } 方法区中类静态属性引用的对象 ``` s 为 GC Root，s 置为 null，经过 GC 后，s 所指向的 properties 对象由于无法与 GC Root 建立关系被回收。 而 m 作为类的静态属性，也属于 GC Root，parameter 对象依然与 GC root 建立着连接，所以此时 parameter 对象并不会被回收。 public class MethodAreaStaicProperties { public static MethodAreaStaicProperties m; public MethodAreaStaicProperties(String name){} } public static void testGC(){ MethodAreaStaicProperties s = new MethodAreaStaicProperties(\"properties\"); s.m = new MethodAreaStaicProperties(\"parameter\"); s = null; } * **方法区中常量引用的对象** m 即为方法区中的常量引用，也为 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。 public class MethodAreaStaicProperties { public static final MethodAreaStaicProperties m = MethodAreaStaicProperties(\"final\"); public MethodAreaStaicProperties(String name){} } public static void testGC(){ MethodAreaStaicProperties s = new MethodAreaStaicProperties(\"staticProperties\"); s = null; } ``` 本地方法栈中引用的对象 引用 引用的使用场景 https://toutiao.io/posts/6wiqyz/preview https://juejin.cn/post/6844904057602064391#heading-5 垃圾回收过程 堆 方法区 永久代垃圾回收主要回收两部分：废弃常量和无用的类 废弃常量同回收java堆类似。（以String对象是\"acb\"为例，没有地方引用到\"abc\"，会被回收）。常量池中其他类(接口)、方法、字段的符号引用类似。 无用的类 1、不存在该类的任何实例 2、加载改类的ClassLoader被回收 3、改类对应的java.lang.Class对应没有任何地方被引用，无法在如何地方通过反射调用 垃圾回收算法(怎么回收垃圾) https://juejin.cn/post/6844904057602064391#heading-24 概述 标记-清除算法 算法描述 标记阶段：标记处所有需要回收的对象； 清除阶段：标记完成后，统一回收所有被标记的对象； 优点 还没想到 不足 效率不高：标记和清除两个过程效率都不高； 空间问题：产生大量不连续的内存碎片，进而无法容纳大对象提早触发另一次GC。 复制算法 算法描述 将可用内存分为容量大小相等的两块，每次只使用其中一块； 当一块用完，就将存活着的对象复制到另一块，然后将这块全部内存清理掉； 优点 不会产生不连续的内存碎片； 提高效率： 回收：每次都是对整个半区进行回收； 分配：分配时也不用考虑内存碎片问题，只要移动堆顶指针，按顺序分配内存即可。 缺点 可用内存缩小为原来的一半了，适合GC过后只有少量存活的新生代，可以根据实际情况，将内存块大小比例适当调整； 如果存活对象数量比较大，复制性能会变得很差。 JVM中新生代的垃圾回收 如下图，分为新生代和老年代。其中新生代又分为一个Eden区和两个Survivor去(from区和to区)，默认Eden : from : to 比例为8:1:1。 可通过JVM参数：-XX:SurvivorRatio配置比例，-XX:SurvivorRatio=8 表示 Eden区大小 / 1块Survivor区大小 = 8。 第一次Young GC 当Eden区满的时候，触发第一次Young GC，把存活对象拷贝到Survivor的from区，清空Eden区。 第二次Young GC 再次触发Young GC，扫描Eden区和from区，把存活的对象复制到To区，清空Eden区和from区。如果此时Survivor区的空间不够了，就会提前把对象放入老年代。 默认的，这样来回交换15次后，如果对象最终还是存活，就放入老年代。 交换次数可以通过JVM参数MaxTenuringThreshold进行设置。 JVM内存模型 JDK8 之前 JDK8 如上图，JDK8的方法区实现变成了元空间，元空间在本地内存中。 JVM内存相关参数： JVM Parameters 内存分配如何保证并发？ 标记-整理算法 算法描述 标记过程与标记-清楚算法一样； 标记完成后，将存活对象向一端移动，然后直接清理掉边界以外的内存。 优点 不会产生内存碎片； 不需要浪费额外的空间进行分配担保； 不足 整理阶段存在效率问题，适合老年代这种垃圾回收频率不是很高的场景； 分代收集算法 当前商业虚拟机都采用该算法。 新生代：复制算法(CG后只有少量的对象存活) 老年代：标记-整理算法 或者 标记-清理算法(GC后对象存活率高) 垃圾回收器 https://juejin.cn/post/6844904057602064391#heading-24 内存分配与回收策略 自动内存管理归结到两个问题：对象内存分配以及回收分配到对象的内存 结构 Eden 区 有将近 98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快 通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。 Survivor 区 Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为 2 个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。 为啥需要？ 不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。 所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代 为啥需要俩？ 设置两个 Survivor 区最大的好处就是解决内存碎片化。 我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。 这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案 Old 区 老年代占据着 2/3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记 — 整理算法。 除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。 大对象 大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及 2 个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了 长期存活对象 虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加 1 岁。当年龄增加到 15 岁时，这时候就会被转移到老年代。当然，这里的 15，JVM 也支持进行特殊设置。 动态对象年龄 虚拟机并不重视要求对象年龄必须到 15 岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。 这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法 空间分配担保 谁进行空间担保？ 　　JVM使用分代收集算法，将堆内存划分为年轻代和老年代，两块内存分别采用不同的垃圾回收算法，空间担保指的是老年代进行空间分配担保 什么是空间分配担保？ 发生Minor GC前，JVM先检查老年代最大可用连续空间是否大于新生代所有对象的总空间 大于：空间足够，直接Minor GC； 小于：进行一次Full GC。 为什么要进行空间担保？ 是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间 Minor Gc 和 Full GC 有什么不同呢？ 针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种： 部分收集 (Partial GC)： 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集； 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集； 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 整堆收集 (Full GC)：收集整个 Java 堆和方法区。 第二部分自动内存管理机制 第3章 垃圾收集器与内存分配策略 https://yq.aliyun.com/articles/753815 https://www.cnblogs.com/shoshana-kong/p/10572563.html https://help.eclipse.org/2020-12/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&cp=37_2_3 https://blog.csdn.net/u010798968/article/details/72835255 android中实践： https://jsonchao.github.io/2019/01/06/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Leakcanary%E6%BA%90%E7%A0%81%EF%BC%89/ https://juejin.cn/post/6844904168075821064 https://juejin.cn/post/6844904090179207176#heading-13 https://developer.android.com/studio/profile/memory-profiler?hl=zh-cn 垃圾收集器的行为、优势、劣势？ GC做的事情： 1、哪些内存需要回收？ 2、什么时候回收？ 3、如何回收？ 监控和调节 根搜索算法：GC Roots 新生代垃圾收集算法： 老年代垃圾收集算法： 垃圾收集器： 暂停所有线程；暂停时间 单线程、多线程 自动内存管理：给对象分配内存、回收分配给对象的内存 什么时候触发回收？ 1.JVM空闲的时候 2.显式调用system.gc（） 3.空间满时 Scavenge GC 一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC， 清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对 年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很 大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲 出来。 Full GC 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调 节。有如下原因可能导致Full GC： 年老代（Tenured）被写满 持久代（Perm）被写满 System.gc()被显示调用 第三部分 虚拟机执行子系统 第6章 类文件结构 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21 https://blog.csdn.net/u010963948/article/details/90080056 https://wiki.jikexueyuan.com/project/java-vm/class.html https://www.cnblogs.com/ysocean/p/11427535.html https://juejin.cn/post/6844903512304795661#heading-0 https://blog.csdn.net/u010963948/article/details/90080056 https://zhuanlan.zhihu.com/p/25823310 https://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html 第8章 虚拟机字节码执行引擎 第9章 类加载及执行子系统的案例与实战 InvocationHandler 接口 动态代理： https://blog.csdn.net/u013803262/article/details/53187363 https://segmentfault.com/a/1190000022789831 powered by Gitbook文档更新时间： 2021-03-22 12:42:41 "},"Android内存.html":{"url":"Android内存.html","title":"Android内存","keywords":"","body":"LowMemoryKiller原理分析 http://gityuan.com/2016/09/17/android-lowmemorykiller/ 面试题 一张图片100x100在内存中的大小？ 内存泄露 什么情况导致内存泄漏-美团 1.资源对象没关闭造成的内存泄漏 描述： 资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。 程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。 2.构造Adapter时，没有使用缓存的convertView 描述： 以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法： public View getView(int position, ViewconvertView, ViewGroup parent) 来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看: android.widget.AbsListView.java --> voidaddScrapView(View scrap) 方法。 示例代码： public View getView(int position, ViewconvertView, ViewGroup parent) { View view = new Xxx(...); ... ... return view; } 修正示例代码： public View getView(int position, ViewconvertView, ViewGroup parent) { View view = null; if (convertView != null) { view = convertView; populate(view, getItem(position)); ... } else { view = new Xxx(...); ... } return view; } 3.Bitmap对象不在使用时调用recycle()释放内存 描述： 有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释： /* •Free up the memory associated with thisbitmap's pixels, and mark the •bitmap as \"dead\", meaning itwill throw an exception if getPixels() or •setPixels() is called, and will drawnothing. This operation cannot be •reversed, so it should only be called ifyou are sure there are no •further uses for the bitmap. This is anadvanced call, and normally need •not be called, since the normal GCprocess will free up this memory when •there are no more references to thisbitmap. / 4.试着使用关于application的context来替代和activity相关的context 这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免 Android内存泄漏。 5.注册没取消造成的内存泄漏 一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。 比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。 但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。 虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。 6.集合中对象没清理造成的内存泄漏 我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。 内存泄露的本质 无法回收无用的对象 OOM，内存泄漏，内存溢出，java引用类型，ANR分析 构造一个内存泄露的场景 什么情况导致oom-乐视-美团 http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html 使用更加轻量的数据结构 Android里面使用Enum Bitmap对象的内存占用 更大的图片 onDraw方法里面执行对象的创建 StringBuilder 造成 oom 的原因 下载一张很大的图，如何保证不 oom？ - Android性能优化（五）之细说Bitmap 说一些引起内存泄漏的场景 检测到内存泄漏怎么修复 什么情况会导致内存泄漏，如何修复？ 为什么会出现oom？ 为了整个Android系统的内存控制需要，Android 系统为每一个应用程序都设置了一个硬性的Dalvik Heap Size 最大限制阈值，这个阈值在不同的设备上会因为 RAM 大小不同而各有差异。如果应用占用内存空间已经接近这个阈值，此时再尝试分配内存的话，很容易引起OutOfMemoryError 的错误。 作者：叛逆的青春不回头 链接：https://www.jianshu.com/p/2c2abadae450 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 哪些原因会导致 oom？ 虚拟机堆内存不足：内存泄漏（内存缓增）、大对象/大图片（内存突增） 内存碎片，无足够连续内存空间：循环中创建对象、字符串拼接... 系统底层限制：FD 数量超出限制、线程数量超出限制、其他系统限制 debug 包有什么修改方式使不出现 oom？ Android为每个进程分配内存时，采用弹性的分配方式，即刚开始并不会给应用分配很多的内存，而是给每一个进程分配一个“够用”的内存大小，这个值由具体的设备决定 在AndroidManifest.xml中的application标签中设置largeHeap为true，可以申请最多的内存的限制 这个内存限制的值是在 /system/build.prop文件中可以查看与修改 作者：叛逆的青春不回头 链接：https://www.jianshu.com/p/2c2abadae450 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 有哪些原因会引起内存泄漏？ https://www.jianshu.com/p/97fb764f2669 内存泄漏有什么方式检测？用过哪些工具，其中的原理是什么？ Java内存问题 及 LeakCanary 原理分析： 基本原理：用ActivityLifecycleCallbacks接口来检测Activity生命周期，主要是在onDestroy()方法中，手动调用 GC，然后利用ReferenceQueue+WeakReference 监听对象回收情况 ，来判断是否有释放不掉的引用，再结合dump memory的hpof文件, 用HaHa分析出泄漏地方； LeakCanary会单独开一进程，用来执行分析任务，和监听任务分开处理。Application中可通过processName判断是否是任务执行进程； 利用主线程空闲的时候执行检测任务，在MessageQueue中加入了一个IdleHandler来得到主线程空闲回调； LeakCanary检测只针对Activiy里的相关对象。其他类无法使用，还得用MAT原始方法 作者：叛逆的青春不回头 链接：https://www.jianshu.com/p/2c2abadae450 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Android内存泄露及管理 （1）内存溢出（OOM）和内存泄露（对象无法被回收）的区别。 （2）引起内存泄露的原因 (3) 内存泄露检测工具 ------>LeakCanary 内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出通俗的讲就是内存不够用。 内存泄露 memory leak：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光 内存泄露原因： 一、Handler 引起的内存泄漏。 解决：将Handler声明为静态内部类，就不会持有外部类SecondActivity的引用，其生命周期就和外部类无关， 如果Handler里面需要context的话，可以通过弱引用方式引用外部类 二、单例模式引起的内存泄漏。 解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏 三、非静态内部类创建静态实例引起的内存泄漏。 解决：把内部类修改为静态的就可以避免内存泄漏了 四、非静态匿名内部类引起的内存泄漏。 解决：将匿名内部类设置为静态的。 五、注册/反注册未成对使用引起的内存泄漏。 注册广播接受器、EventBus等，记得解绑。 六、资源对象没有关闭引起的内存泄漏。 在这些资源不使用的时候，记得调用相应的类似close（）、destroy（）、recycler（）、release（）等方法释放。 七、集合对象没有及时清理引起的内存泄漏。 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。 作者：王培921223 链接：https://www.jianshu.com/p/7661c292195a 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 内存泄漏发生的情况有哪些？ 答： 主要有四类情况 集合类泄漏 单例/静态变量造成的内存泄漏 匿名内部类/非静态内部类 资源未关闭造成的内存泄漏 具体解析如下：内存泄漏三问—vivo真题 gc 垃圾回收 https://github.com/kesenhoo/android-training-course-in-chinese/blob/master/performance/memory.md https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/index.html https://mp.weixin.qq.com/s/CUU3Ml394H_fkabhNNX32Q GC回收算法 Java GC机制，为什么要执行 GC 那些不可能再被任何途径使用的对象，需要被回收，否则内存迟早都会被消耗空 JVM,JMM,java加载对象的步骤，classLoader,GC回收算法 java中GC 是如何判断对象是可以被回收的？ Java 垃圾收集的原理： 自动垃圾收集的前提是清楚哪些内存可以被释放，主要有两个方面，最主要部分就是对象实例，存储在堆上的；另一个是方法区中的元数据等信息，例如类型不再使用，卸载该 Java 类比较合理； 对象实例收集主要是两种基本算法，引用计数和可达性分析，Java 选择的可达性分析。JVM 会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量**，作为 GC Roots。 作者：叛逆的青春不回头 链接：https://www.jianshu.com/p/9bfb74c50f6c 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 JAVA GC原理 垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象 ，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能。 作者：王培921223 链接：https://www.jianshu.com/p/7661c292195a 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 JVM JVM的理解 http://www.infoq.com/cn/articles/java-memory-model-1 jvm虚拟机，堆和栈的结构 jvm虚拟机，堆和栈的结构，栈帧，JMM java 虚拟机类加载器分类，类加载器的代理机制有什么好处？ （1）类加载器分类 启动类加载器：加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader； 扩展类加载器：加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类； 系统/应用类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它； 注：类加载器树状组织结构，除了引导类加载器之外，所有的类加载器都有一个父类加载器。类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。 （2）类加载器的代理机制 原理：类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推； 作用：代理模式是为了保证 Java 核心库的类型安全。对于Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。 传送门：深入探讨 Java 类加载器 Java 虚拟机是如何判定两个 Java 类是相同的？ Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器 (defining loader) 是否一样。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的； 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 Java 类的加载过程是什么？ Java 类的加载过程 - 三个主要步骤：加载、链接、初始化： （1）加载 - 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构 (Class 对象) 由于类加载器的代理机制，启动类加载过程的类加载器和真正完成类加载工作的类加载器，有可能不同； 启动类的加载过程通过调用loadClass()来实现，称为初始加载器 (initiating loader)；而完成类的加载工作通过调用defineClass()来实现，称为类的定义加载器 (defining loader)。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器； loadClass() 抛出的是 java.lang.ClassNotFoundException 异常，而 defineClass() 抛出的是 java.lang.NoClassDefFoundError 异常； 类加载器在成功加载某个类之后，会把得到的 java.lang.Class 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载 (即 loadClass()不会被重复调用) （2）链接 - 将原始的类定义信息平滑地转化入 JVM 运行的过程中 验证：核验字节信息是符合 Java 虚拟机规范； 准备：创建类或接口中的静态变量并初始化，侧重分配所需要的内存空间（与初始化阶段区分开）； 解析：替换常量池中的符号引用为直接引用，类、接口、方法和字段等各个方面的解析等 （3）初始化 - 真正执行类初始化的代码逻辑，包括静态字段赋值的动作，以及类中静态初始化块内的逻辑。编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑 作者：叛逆的青春不回头 链接：https://www.jianshu.com/p/9bfb74c50f6c 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ClassLoader 的双亲委派机制 - 深入探讨 Java 类加载器 Java 中的几种引用类型，虚引用的使用场景？ java的几种引用类型，弱引用的使用场景？ JVM 堆内存溢出后，其他线程是否可继续工作？ LeakCanary LeakCanary 实现原理 http://blog.csdn.net/cloud_huan/article/details/53081120 LeakCanary的收集内存泄露是在 Activity 的什么时机，大致原理 android虚拟机 java虚拟机与Dalvik和ART区别 Java虚拟机： 1、java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多。 2、java虚拟机运行的是java字节码。（java类会被编译成一个或多个字节码.class文件） Dalvik虚拟机： 1、dalvik虚拟机是基于寄存器的 2、Dalvik运行的是自定义的.dex字节码格式。（java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据 3、常量池已被修改为只使用32位的索引，以 简化解释器。 4、一个应用，一个虚拟机实例，一个进程（所有android应用的线程都是对应一个linux线程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个android dalvik应用程序都被赋予了一个独立的linux PID(app_*)） 作者：王培921223 链接：https://www.jianshu.com/p/7661c292195a 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Android虚拟机有哪些？区别是什么？ powered by Gitbook文档更新时间： 2021-03-22 11:42:35 "}}